/**
 * @file AS5047P.h
 * @author Jonas Merkle [JJM] (jonas@jjm.one)
 * @brief This is the main sourcefile of the AS5047P Library.
 * @version 3.0.0
 * @date 2021-10-29
 * 
 * @copyright Copyright (c) 2021 Jonas Merkle. This project is released under the GPL-3.0 License License.
 * 
 */

#include "AS5047P.h"

// as5047p libraries
#include "./util/AS5047P_Util.h"

// Constructors ------------------------------------------------

#if defined(AS5047P_OP_MODE_Arduino)
AS5047P::AS5047P(const uint8_t chipSelectPinNo, const uint32_t spiSpeed) : _spiInterface(chipSelectPinNo, spiSpeed) {

}
#endif // AS5047P_OP_MODE_Arduino

#if defined(AS5047P_OP_MODE_Zephyr)
AS5047P::AS5047P(const struct spi_dt_spec *spiDevSpec) : _spiInterface(spiDevSpec) {

}
#endif // AS5047P_OP_MODE_Zephyr

// -------------------------------------------------------------

// Init --------------------------------------------------------

bool AS5047P::checkSPICon() const {
    
    // test write to an readonly register (error register)
    _spiInterface.write(AS5047P_Types::ERRFL_t::REG_ADDRESS, 0x0007);

    // read the error register (should contain an error)
    AS5047P_Types::ERRFL_t errorReg = read_ERRFL();

    // if error register contains no errors something is not right.
    return (
        errorReg.data.values.FRERR == 0 &&
        errorReg.data.values.INVCOMM == 0 &&
        errorReg.data.values.PARERR == 1
    );

}

bool AS5047P::initSPI() {

    _spiInterface.init();

    return checkSPICon();

}

// -------------------------------------------------------------

// Util --------------------------------------------------------

bool AS5047P::checkForComErrorF(AS5047P_Types::ERROR_t *errorOut) const {

    // read the error reg
    AS5047P_Types::ERROR_t e;
    auto errorReg = AS5047P::read_ERRFL(&e, true, false, false);

    // write error info from current communication in errorOut
    errorOut->controllerSideErrors.flags.CONT_SPI_PARITY_ERROR = e.controllerSideErrors.flags.CONT_SPI_PARITY_ERROR;

    // write the ERRFL register content in errorOut
    errorOut->sensorSideErrors.flags.SENS_SPI_FRAMING_ERROR |= errorReg.data.values.FRERR;
    errorOut->sensorSideErrors.flags.SENS_SPI_INVALID_CMD |= errorReg.data.values.INVCOMM;
    errorOut->sensorSideErrors.flags.SENS_SPI_PARITY_ERROR |= errorReg.data.values.PARERR;

    // check for no errors
    if (!errorReg.data.values.FRERR &&
        !errorReg.data.values.INVCOMM &&
        !errorReg.data.values.PARERR &&
        !errorOut->controllerSideErrors.flags.CONT_SPI_PARITY_ERROR) {
        return true;
    }
    else {
        return false;
    }
}

bool AS5047P::checkForSensorErrorF(AS5047P_Types::ERROR_t *errorOut) const {

    // read the diag reg
    AS5047P_Types::ERROR_t e;
    auto diagReg = AS5047P::read_DIAAGC(&e, true, false, false);

    // write error info from current communication in errorOut
    errorOut->controllerSideErrors.flags.CONT_SPI_PARITY_ERROR = e.controllerSideErrors.flags.CONT_SPI_PARITY_ERROR;

    // write the ERRFL register content in errorOut
    errorOut->sensorSideErrors.flags.SENS_CORDIC_OVERFLOW_ERROR |= diagReg.data.values.COF;
    errorOut->sensorSideErrors.flags.SENS_OFFSET_COMP_ERROR |= ~diagReg.data.values.LF;         // bit flip: O = not compensated -> error 
    errorOut->sensorSideErrors.flags.SENS_MAG_TOO_HIGH |= diagReg.data.values.MAGH;
    errorOut->sensorSideErrors.flags.SENS_MAG_TOO_LOW |= diagReg.data.values.MAGL;

    // check for no errors
    if (!diagReg.data.values.COF &&
        !diagReg.data.values.LF &&
        !diagReg.data.values.MAGH &&
        !diagReg.data.values.MAGL &&
        !errorOut->controllerSideErrors.flags.CONT_SPI_PARITY_ERROR) {
        return true;
    }
    else {
        return false;
    }
}

bool AS5047P::verifyWittenRegF(uint16_t regAddress, uint16_t expectedData) const {

    // check parity of expected data
    if (!AS5047P_Util::parityCheck(expectedData)) {
        return false;
    }
    
    // send read command
    AS5047P_Types::SPI_Command_Frame_t readCMD(regAddress, AS5047P_TYPES_READ_CMD);

    // read register content
    AS5047P_Types::SPI_ReadData_Frame_t recData(_spiInterface.read(readCMD.data.raw));

    // check parity of received data
    if (!AS5047P_Util::parityCheck(recData.data.raw)) {
        return false;
    }
    
    // check read reg data and expected data and return the result
    return recData.data.raw == expectedData;
}


#if (defined(AS5047P_OP_MODE_Arduino) && (defined(ARDUINO_ARCH_SAMD) || defined(CORE_TEENSY))) || defined(AS5047P_OP_MODE_Zephyr)
std::string AS5047P::readStatusAsStdString() const {

    AS5047P_Types::ERRFL_t errorReg = read_ERRFL();
    AS5047P_Types::DIAAGC_t diagReg = read_DIAAGC();

    std::string str;
    str.reserve(AS5047P_INFO_STRING_BUFFER_SIZE);

    str.append("#########################\n");
    str.append(" Error Information:\n");
    str.append("-------------------------\n");
    str.append("- Framing error:   ");
    str.append(AS5047P_Util::to_string(errorReg.data.values.FRERR));
    str.append("\n");
    str.append("- Invalid command: ");
    str.append(AS5047P_Util::to_string(errorReg.data.values.INVCOMM));
    str.append("\n");
    str.append("- Parity error:    ");
    str.append(AS5047P_Util::to_string(errorReg.data.values.PARERR));
    str.append("\n");
    str.append("#########################\n");
    str.append(" Diagnostic Information: \n");
    str.append("-------------------------\n");
    str.append("- AGC Value:       ");
    str.append(AS5047P_Util::to_string(diagReg.data.values.AGC));
    str.append("\n");
    str.append("- Offset comp.:    ");
    str.append(AS5047P_Util::to_string(diagReg.data.values.LF));
    str.append("\n");
    str.append("- CORDIC overflow: ");
    str.append(AS5047P_Util::to_string(diagReg.data.values.COF));
    str.append("\n");
    str.append("- MAG too high:    ");
    str.append(AS5047P_Util::to_string(diagReg.data.values.MAGH));
    str.append("\n");
    str.append("- MAG too low:     ");
    str.append(AS5047P_Util::to_string(diagReg.data.values.MAGL));
    str.append("\n");
    str.append("#########################\n");

    str.shrink_to_fit();

    return str;

}
#endif // (AS5047P_OP_MODE_Arduino && (ARDUINO_ARCH_SAMD || CORE_TEENSY)) || AS5047P_OP_MODE_Zephyr

#if defined(AS5047P_OP_MODE_Arduino)
String AS5047P::readStatusAsArduinoString() const {
    AS5047P_Types::ERRFL_t errorReg = read_ERRFL();
    AS5047P_Types::DIAAGC_t diagReg = read_DIAAGC();

    char buf[AS5047P_INFO_STRING_BUFFER_SIZE] = {0};

    sprintf(buf,
        "#########################\n Error Information:\n-------------------------\n- Framing error:   %d\n- Invalid command: %d\n- Parity error:    %d\n#########################\n Diagnostic Information: \n-------------------------\n- AGC Value:       %d\n- Offset comp.:    %d\n- CORDIC overflow: %d\n- MAG too high:    %d\n- MAG too low:     %d\n#########################\n",
        errorReg.data.values.FRERR, errorReg.data.values.INVCOMM, errorReg.data.values.PARERR,
        diagReg.data.values.AGC, diagReg.data.values.LF, diagReg.data.values.COF, diagReg.data.values.MAGH, diagReg.data.values.MAGL
    );

    return String(buf);
}
#endif // AS5047P_OP_MODE_Arduino

// -------------------------------------------------------------

// Read High-Level ---------------------------------------------

uint16_t AS5047P::readMagnitude(AS5047P_Types::ERROR_t *errorOut, bool verifyParity, bool checkForComError, bool checkForSensorError) const {

    AS5047P_Types::MAG_t res = AS5047P::read_MAG(errorOut, verifyParity, checkForComError, checkForSensorError);
    return res.data.values.CMAG;

}

uint16_t AS5047P::readAngleRaw(bool withDAEC, AS5047P_Types::ERROR_t *errorOut, bool verifyParity, bool checkForComError, bool checkForSensorError) const {

    if (withDAEC) {
        AS5047P_Types::ANGLECOM_t res = AS5047P::read_ANGLECOM(errorOut, verifyParity, checkForComError, checkForSensorError);
        return res.data.values.DAECANG;
    }
    else {
        AS5047P_Types::ANGLEUNC_t res = AS5047P::read_ANGLEUNC(errorOut, verifyParity, checkForComError, checkForSensorError);
        return res.data.values.CORDICANG;
    }

}

float AS5047P::readAngleDegree(bool withDAEC, AS5047P_Types::ERROR_t *errorOut, bool verifyParity, bool checkForComError, bool checkForSensorError) const {

    if (withDAEC) {
        AS5047P_Types::ANGLECOM_t res = AS5047P::read_ANGLECOM(errorOut, verifyParity, checkForComError, checkForSensorError);
        return ((float)res.data.values.DAECANG/(float)16384)*360;
    }
    else {
        AS5047P_Types::ANGLEUNC_t res = AS5047P::read_ANGLEUNC(errorOut, verifyParity, checkForComError, checkForSensorError);
        return ((float)res.data.values.CORDICANG/(float)16384)*360;
    }

}

// -------------------------------------------------------------

// Template functions ------------------------------------------

template<class T>
T AS5047P::readReg(AS5047P_Types::ERROR_t *errorOut, bool verifyParity, bool checkForComError, bool checkForSensorError) const {

    // send read command
    AS5047P_Types::SPI_Command_Frame_t readCMD(T::REG_ADDRESS, AS5047P_TYPES_READ_CMD);

    // read data
    AS5047P_Types::SPI_ReadData_Frame_t recData(_spiInterface.read(readCMD.data.raw));

    if (errorOut == nullptr) {
        return T(recData.data.raw);
    }

    // reset error data
    *errorOut = AS5047P_Types::ERROR_t();

    // verify parity bit
    if (verifyParity) {
        errorOut->controllerSideErrors.flags.CONT_SPI_PARITY_ERROR = !AS5047P_Util::parityCheck(recData.data.raw);
    }

    // check for communication error
    if (checkForComError) {
        checkForComErrorF(errorOut);
    }

    // check for sensor error
    if (checkForSensorError) {
        checkForSensorErrorF(errorOut);

        // check for communication error
        if (checkForComError) {
            checkForComErrorF(errorOut);
        }
    }

    return T(recData.data.raw);

}

template<class T>
bool AS5047P::writeReg(const T *regData, AS5047P_Types::ERROR_t *errorOut, bool checkForComError, bool verifyWittenReg) const {

    // build write command and data (includes parity calculation)
    AS5047P_Types::SPI_Command_Frame_t writeCMD(T::REG_ADDRESS, AS5047P_TYPES_WRITE_CMD);
    AS5047P_Types::SPI_WriteData_Frame_t writeData(regData->data.raw, 0);
    _spiInterface.write(writeCMD.data.raw, writeData.data.raw);

    if (errorOut == nullptr) {
        return true;
    }

    // reset error data
    *errorOut = AS5047P_Types::ERROR_t();

    // check for communication error
    if (checkForComError) {
        checkForComErrorF(errorOut);
    }

    // check for sensor error
    if (verifyWittenReg) {
        checkForSensorErrorF(errorOut);

        // check for communication error
        if (checkForComError) {
            checkForComErrorF(errorOut);
        }
    }

    // check error information and return
    return errorOut->noError();;

}

// -------------------------------------------------------------

// Read Volatile Registers -------------------------------------

auto AS5047P::read_ERRFL(AS5047P_Types::ERROR_t *errorOut, bool verifyParity, bool checkForComError, bool checkForSensorError) const -> AS5047P_Types::ERRFL_t {

    return readReg<AS5047P_Types::ERRFL_t>(errorOut, verifyParity, checkForComError, checkForSensorError);

}

auto AS5047P::read_PROG(AS5047P_Types::ERROR_t *errorOut, bool verifyParity, bool checkForComError, bool checkForSensorError) const -> AS5047P_Types::PROG_t {
    
    return readReg<AS5047P_Types::PROG_t>(errorOut, verifyParity, checkForComError, checkForSensorError);

}

auto AS5047P::read_DIAAGC(AS5047P_Types::ERROR_t *errorOut, bool verifyParity, bool checkForComError, bool checkForSensorError) const -> AS5047P_Types::DIAAGC_t {

    return readReg<AS5047P_Types::DIAAGC_t>(errorOut, verifyParity, checkForComError, checkForSensorError);

}

auto AS5047P::read_MAG(AS5047P_Types::ERROR_t *errorOut, bool verifyParity, bool checkForComError, bool checkForSensorError) const -> AS5047P_Types::MAG_t {
    
    return readReg<AS5047P_Types::MAG_t>(errorOut, verifyParity, checkForComError, checkForSensorError);

}

auto AS5047P::read_ANGLEUNC(AS5047P_Types::ERROR_t *errorOut, bool verifyParity, bool checkForComError, bool checkForSensorError) const -> AS5047P_Types::ANGLEUNC_t {
    
    return readReg<AS5047P_Types::ANGLEUNC_t>(errorOut, verifyParity, checkForComError, checkForSensorError);

}

auto AS5047P::read_ANGLECOM(AS5047P_Types::ERROR_t *errorOut, bool verifyParity, bool checkForComError, bool checkForSensorError) const -> AS5047P_Types::ANGLECOM_t {

    return readReg<AS5047P_Types::ANGLECOM_t>(errorOut, verifyParity, checkForComError, checkForSensorError);

}

// -------------------------------------------------------------

// Write Volatile Registers ------------------------------------
    
bool AS5047P::write_PROG(const AS5047P_Types::PROG_t *regData, AS5047P_Types::ERROR_t *errorOut, bool checkForComError, bool verifyWittenReg) const {
    
    return writeReg<AS5047P_Types::PROG_t>(regData, errorOut, checkForComError, verifyWittenReg);

}

// -------------------------------------------------------------

// Read Non-Volatile Registers ---------------------------------

auto AS5047P::read_ZPOSM(AS5047P_Types::ERROR_t *errorOut, bool verifyParity, bool checkForComError, bool checkForSensorError) const -> AS5047P_Types::ZPOSM_t {
    
    return readReg<AS5047P_Types::ZPOSM_t>(errorOut, verifyParity, checkForComError, checkForSensorError);

}

auto AS5047P::read_ZPOSL(AS5047P_Types::ERROR_t *errorOut, bool verifyParity, bool checkForComError, bool checkForSensorError) const -> AS5047P_Types::ZPOSL_t {
    
    return readReg<AS5047P_Types::ZPOSL_t>(errorOut, verifyParity, checkForComError, checkForSensorError);

}

auto AS5047P::read_SETTINGS1(AS5047P_Types::ERROR_t *errorOut, bool verifyParity, bool checkForComError, bool checkForSensorError) const -> AS5047P_Types::SETTINGS1_t {
    
    return readReg<AS5047P_Types::SETTINGS1_t>(errorOut, verifyParity, checkForComError, checkForSensorError);

}

auto AS5047P::read_SETTINGS2(AS5047P_Types::ERROR_t *errorOut, bool verifyParity, bool checkForComError, bool checkForSensorError) const -> AS5047P_Types::SETTINGS2_t {
    
    return readReg<AS5047P_Types::SETTINGS2_t>(errorOut, verifyParity, checkForComError, checkForSensorError);
}

// -------------------------------------------------------------

// Write Non-Volatile Registers --------------------------------

bool AS5047P::write_ZPOSM(const AS5047P_Types::ZPOSM_t *regData, AS5047P_Types::ERROR_t *errorOut, bool checkForComError, bool verifyWittenReg) const {
    
    return writeReg<AS5047P_Types::ZPOSM_t>(regData, errorOut, checkForComError, verifyWittenReg);

}

bool AS5047P::write_ZPOSL(const AS5047P_Types::ZPOSL_t *regData, AS5047P_Types::ERROR_t *errorOut, bool checkForComError, bool verifyWittenReg) const {
    
    return writeReg<AS5047P_Types::ZPOSL_t>(regData, errorOut, checkForComError, verifyWittenReg);

}

bool AS5047P::write_SETTINGS1(const AS5047P_Types::SETTINGS1_t *regData, AS5047P_Types::ERROR_t *errorOut, bool checkForComError, bool verifyWittenReg) const {
    
    return writeReg<AS5047P_Types::SETTINGS1_t>(regData, errorOut, checkForComError, verifyWittenReg);

}

bool AS5047P::write_SETTINGS2(const AS5047P_Types::SETTINGS2_t *regData, AS5047P_Types::ERROR_t *errorOut, bool checkForComError, bool verifyWittenReg) const {
    
    return writeReg<AS5047P_Types::SETTINGS2_t>(regData, errorOut, checkForComError, verifyWittenReg);

}

// -------------------------------------------------------------
